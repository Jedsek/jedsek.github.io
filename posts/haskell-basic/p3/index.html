<!doctype html><html class=scroll-smooth lang=zh-Hans><head><meta charset=utf-8><link crossorigin href=/manifest.json rel=manifest><script src=/scripts/custom/loadscript.js></script><link href=/styles/third_party/highlight.min.css rel=stylesheet><link href=/styles/third_party/highlight_themes/atom-one-dark.css rel=stylesheet><script src=/scripts/third_party/pjax.min.js></script><script src=/scripts/third_party/quicklink.umd.min.js></script><script src=/scripts/third_party/jquery.min.js></script><script src=/scripts/third_party/highlight/highlight.min.js></script><script src=/scripts/third_party/highlight/languages/rust.min.js></script><script src=/scripts/third_party/highlight/languages/nix.min.js></script><script src=/scripts/third_party/highlight/languages/haskell.min.js></script><script src=/scripts/third_party/highlight/languages/gleam.min.js></script><script src=/scripts/third_party/highlight/languages/scheme.min.js></script><link href=/iconfonts/iconfont.css rel=stylesheet><link href=/styles/custom/tailwind.css rel=stylesheet><link href=/styles/custom/style.css rel=stylesheet><script src=/scripts/custom/pjax.js></script><script src=/scripts/custom/pwa_install.js></script><script>document.documentElement.setAttribute(`data-theme`,`dark`)</script><script>if(navigator.serviceWorker!=null){navigator.serviceWorker.register(`/sw.js`).then((a=>{console.log(`Registered events at scope: `,a.scope)}))}</script><script>var GetCookie=(a=>{let e=0;var b=document.cookie.split(`;`);for(var c=e;c<b.length;c++){var d=b[c].split(`=`);if(a==d[e]){return unescape(d[1])}};return null});var SetCookie=((a,b)=>{document.cookie=a+ `=`+ escape(b)+ `; SameSite=None; Secure;`});var scrollback=(()=>{let a=`scroll`;if(GetCookie(a)!=null){const b=GetCookie(a);document.documentElement.scrollTo({top:b,left:0,behavior:`instant`})}})</script><script>window.addEventListener(`load`,()=>{quicklink.listen()})</script><script>loadExternalScript(`//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js`,(()=>{console.log(`External script loaded and executed.`)}));document.addEventListener(`pjax:complete`,(()=>{loadExternalScript(`//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js`,(()=>{console.log(`External script loaded and executed.`)}))}))</script><title> Jedsek | Blog </title><body onscroll='SetCookie("scroll",document.documentElement.scrollTop);' class=flex id=body onload=scrollback();><script src=/scripts/custom/fireworks.js></script><div class="flex flex-rol grow"><div class="content w-80 flex flex-col break-words pr-2 border-2 grow border-b-0 border-neutral-800 animate-in fade-in slide-in-from-top-8 duration-1000" style=background-color:#3b3b3b><div class=break-words style=min-height:100vh><div class="p-4 flex justify-center text-4xl" style=opacity:.84>haskell-basic-p3~> 函数式介绍</div><div class="p-4 flex align-center text-sm hover:scale-125 duration-300 w-fit" style=color:#999;margin-top:-16px;margin-left:auto;margin-right:auto><~~ 发表日期:2022-06-26 | 访问量: <span class=text-sm id=busuanzi_container_page_pv style=color:#999> <span class=text-sm id=busuanzi_value_page_pv style=color:#999></span></span> | 本文词数:3274 | 预计阅读时间:17分钟 ~~></div><div class=p-4><blockquote><p>何为函数式编程(FP, 即Functional Programming) ?</blockquote><span id=continue-reading></span><p>同系列传送门: <a href=/categories/haskell-basic>haskell-basic</a><p>本节我们将介绍下函数式编程, 尽量不涉及代码, 都是概念上的东西<br> 那么, 开始吧!<h1 id=bian-cheng-fan-shi>编程范式</h1><h2 id=gai-lan>概览</h2><p>FP, 是一种名叫函数式的, 强大的编程范式, 因此, 我想先讲一讲什么是编程范式<p>编程范式是一种思考方式, 技术, 语言范式, 编程模型<br> 在世界上, 有许多编程范式, 最主要的有:<table><thead><tr><th style=text-align:left>简称<th style=text-align:left>中文名<th style=text-align:left>英文名<tbody><tr><td style=text-align:left>FP<td style=text-align:left>函数式编程<td style=text-align:left>Functional Programming<tr><td style=text-align:left>OOP<td style=text-align:left>面向对象编程<td style=text-align:left>Object-Oriented Programming<tr><td style=text-align:left>POP<td style=text-align:left>面向过程编程<td style=text-align:left>Procedure-Oriented Programming<tr><td style=text-align:left>LP<td style=text-align:left>逻辑式编程<td style=text-align:left>Logic Programming<tr><td style=text-align:left>DP<td style=text-align:left>声明式编程<td style=text-align:left>Declarative Programming<tr><td style=text-align:left>IP<td style=text-align:left>命令式编程<td style=text-align:left>Imperative Programming</table><p>编程范式实在太多, 但不用刻意去记忆, 这些都是些顾名思义的东西<br> 记住FP与OOP这两个缩写即可, 这两个是最常被提及的, 其他的无需记忆<p>编程范式, 它就像是国家的意识形态一样, 具有指导意义, 对如何编程求解问题的思考方法有巨大影响<br> 下面是一些编程范式的例子:<p><strong>提示</strong> 如果你已经了解过以下范式, 直接跳到 <a href=https://jedsek.xyz/posts/haskell-basic/p3/#zong-jie><strong>总结</strong></a> 吧<ul><li><p>面向过程:<br> 优点:<br> 解决问题时, 强调过程, 与人本身的思考方式一致, 符合直觉<br> 缺点:<br> 代码复用能力差, 扩展性差, 繁琐 <br></p><li><p>面向对象:<br> 优点:<br> 将问题抽象为一个个对象, 通过建立模型, 使用继承/多态等来描述世界, 复用代码的能力强悍<br> 缺点:<br> 不能适用于所有问题, 硬套范式可能会让代码变得更加繁琐 <br></p><li><p>逻辑式: 优点:<br> 通过建立 <code>事实</code>, 告诉编程器这些都是绝对正确的, 随后根据逻辑关系直接求解, 十分神奇<br> 缺点: 玄学编程, 可能想象不到怎么样建立出 <code>能正确求解的前提条件/定义</code>, 也可能因推理过于复杂, 导致性能低下 <br></p><li><p>函数式: 优点: 通过以数学中的 <code>函数</code> 为指导, 强调结果, 不关注过程, 通过数据不可变极大减少复杂性<br> 缺点:<br> 学习难度较大, 性能因不可变数据, 不可避免地会低下一些 <br></p><li><p>命令式:<br> 有些说法是命令式指类似汇编这种的, 还有的说命令式与面向过程叫法不同而已<br> 我其实也不是太能区分这两者, 大家在大多数情况下直接认为两者约等于即可<br> 毕竟都2022年了, 现在不太需要关注这些低级层面的差异了<br> 现在该关注的, 是更大差异的范式们, 比如面向过程与面向对象, 函数式与面向对象等等 <br></p><li><p>声明式:<br> 指你编程依靠描述, 而非面向过程地去思考<br> 这种范式常见于一些DSL(领域特定语言), 以此简化在某领域下的开发<br> DSL, 即为专门领域创造的语法, 是为了专注于该领域的开发, 比如HTML写网页, SQL写数据库<br> 特点是一旦脱离相关领域, 语法就不再便利 <br></p></ul><h2 id=zong-jie>总结</h2><p>各种编程范式有各自的特点, 人们通过研究它们, 探究高效的编程方式<br> 编程范式并非严格的互相独立的, 它们大多在概念上也存在交集<p>比如:<ul><li>面向过程/面向对象 && 命令式<li>函数式/逻辑式 && 声明式<li>混合一种, 两种, 甚至各种范式</ul><p>再比如, 现代的编程语言, 一般都汲取了函数式编程中的思想<br> 比如匿名函数, 高阶函数等在函数式语言中较低级的概念, 被一些面向对象的语言使用后, 也能爆发出不俗的威力<br> 再比如 Rust 中的 Option/Result, 有着 Haskell 的影子<p>相信经过本小节, 你对什么是编程范式有了一个初步的认知<br> 接下来, 我们就要专注于本节的主角, 函数式<p>简单来说, 函数式编程依靠着数学的威力, 将其引入编程的概念之中<br> 让我们开始对函数式的正式介绍吧!<hr><h1 id=gao-jie-han-shu>高阶函数</h1><p>高阶函数(HOF, Higher-order Functions), 指一个作为参数, 或当作返回值的函数<p>你可能经常会听到这么一句话: 在 XXX 语言中, 函数被视为一等公民<br> 函数被视为一等公民, 指函数地位突出, 不会被限制, 通常与那些不支持HOF的编程语言做比较<br> 比如匿名函数, Lambda表达式, 闭包, 其实都是因为HOF(函数可以被当作参数传递)<br> <del>(话说2022年了, 主流语言或多或少都支持HOF了, 连C语言都能模拟出来呢)</del><p>一句话概括: 函数能被轻松随意地传递, 很自由, 就像一等公民<hr><h1 id=bu-ke-bian-shu-ju>不可变数据</h1><p>不可变数据(Immutable Data), 指你无法修改已经存在的数据<p>换句话说, 当你想进行新运算, 得到新数据时, 不是替换进原有的数据, 而是新开辟一块空间来存放它<br> 被创建的值, 你将永远无法修改, 就如同数学里那样, 相信我, 当你第一次学编程时, 总会对 <code>变量</code> 感到困惑<p>这也意味着, 你不再需要关注一些与计算机底层有关的奇技淫巧, 而是专注于问题本身<br> 但有个道理亘古不变: 随着抽象等级的提高, 就越偏移底层, 可能会造成更多的资源浪费<p>而且, 可变性还会影响并发性, 出现一些奇奇怪怪的错误, 得学习各种锁模型或其他同步机制<br> 但不可变的数据能够有效降低并发的难度<p>而且也别太担心效率, 虽然肯定会低点, 但也没小瞧现代编译器的疯狂优化啊<br> 比如每次计算不一定会产生新值, 而是通过共享内存, 达到重复使用旧值<hr><h1 id=fu-zuo-yong>副作用</h1><p>副作用(Side Effects), 指与外界发生的交互<p>假设有这么一个函数:<br> 它接受一个参数作为文件名, 进行读取, 输出内容, 即使这么简单, 也做不到相同的输入, 能得到相同的输出<br> 可能你无权读取文件, 可能文件不存在, 可能文件被修改过, 所以, 输入一个固定路径, 不一定能得到固定的输出<p>因此, 这种IO操作, 便是种副作用, 因为它涉及到与外界的交互, 可能产生无法预测的事情<br> 这种超脱于语言, 来自更真实世界的交互, 我们称之为 <code>副作用</code><p>副作用包括, 但不限于:<ul><li>发送网络请求<li>访问系统状态<li>操作数据库<li>操作DOM<li>IO操作<li>修改函数外部的变量<li>使用具有副作用的函数 (传播性)</ul><p>你会注意到 <code>修改函数外部的变量</code>, 它也可以看作 <code>与外界的交互</code><br> 比如, 若该函数修改了一个函数外部的值, 并且返回值依靠这个不固定的值<br> 那么这将无法保证相同输入, 能得到相同输出<p>但是, 程序就是依靠副作用来产生价值的, 副作用让我们能够更改外部条件, 进行交互<br> 绝对的没有副作用, 意味着这个程序绝对的没用<hr><h1 id=yin-yong-tou-ming>引用透明</h1><p>引用透明(RT, Referential Transparency), 指某个表达式, 能替换为它计算得到的值, 且替换前后的语义一定等价<p>引用透明性, 是个存在于众多学说中的知识, 不光是计算机, 还有数学, 哲学, 语言学等<br> 以下是数学中的 RT, 简单来讲, 就是等式推导:<p>f(x) = (x+1)^2^ f(2) = (2+1)^2^ = (3)^2^ = 9<p>可以看到, <code>2+1</code>可以被<code>3</code>代替, 且替换前后的语义一致, 这便是数学中的 RT, 或者称呼它为 <code>等式推导</code>:<br> 某个 <code>父表达式</code> 由许多 <code>子表达式</code> 组成, 如果可以将这些 <code>子表达式</code> 替换为它们计算得到的对应值, 就能简化这个 <code>父表达式</code><br> 计算机中的 RT, 也差不多是这个意思, 只要某个表达式能被替换, 且语义不变, 就具有 RT<p>总而言之, 就是替换, 替换, 还是替换<br> 即使效率变化, 只要语义不变就行, 这有利于让推导问题变得容易, 删除大量冗杂的代码, 方便进行重构等<p>RT 还能与 non-RT(非引用透明) 进行对比, 体现 RT 的好处:<br> 若有这么个函数:<pre class=language-haskell data-lang=haskell><code class=language-haskell data-lang=haskell>double_x(x: Int): Int {
    println(x);
    return x+x;
}
</code></pre><p>那么, 它就不具有 RT, 因为它涉及到了 IO操作(打印了x)<br> 此时进行替换的话, 比如 <code>double_x(10) -> 20</code>, 因为后者少了次打印, 语义不一致<br> 假设你将其中10次对 <code>double_x(x)</code> 的调用, 都用 <code>x+x</code> 来替换, 那你将缺少10次打印<p>这只是个简单的例子, 你完全能将函数中的 <code>println(x)</code>, 换成其他具有副作用, 而非单纯数运算的表达式<br> 使用这些 non-RT 的家伙, 你将丧失进行恒等的能力, 问题推导更加复杂, 排查错误十分困难<br> 你将需要额外使用复杂的工具, 去分析一段复杂的代码<br> 这通常是一些 BUG 的来源<p>RT, 即引用透明, 注定与副作用互斥<hr><h1 id=chun-han-shu>纯函数</h1><p>纯函数(Pure Functions), 表示引用透明的函数<p>引用透明的性质, 一个表达式可以拥有, 一个函数也可以拥有, 我们把这样的函数叫纯函数, 仅此而已<br> 相对应的, 还有纯操作, 纯表达式, 纯代码等等差不多意思的表述, 知道就好<p>因为纯函数的引用透明性, 它不会去修改外界状态, 不去交互, 只是根据参数, 自给自足地算出结果而已<br> 简单概括: 纯函数是一个独立的函数, 外面发生了什么鸟事, 和我有屁关系<p>一个函数独立, 可能没啥, 一堆函数独立, 表示它们可以一起计算, 因为它们之间没有交互, 比如:<br> 有三个纯函数: <code>f(x), h(x), g(x)</code>, 那么 <code>f(x) + h(x) + g(x)</code> 中, 三个函数直接并行计算即可<br> 这意味着, 像 Haskell 这种语言, 本身就具有强大的并发性<p>但纯函数不是神, 无可避免要依靠副作用, 即使如此, 你也应尽量将 非纯函数 中纯的部分抽离出来<hr><h1 id=lambdayan-suan>Lambda演算</h1><p>你绝对绝对使用过 lambda(λ), 比如各大语言中的匿名函数:<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>// 在列表中先取出大于 0 的数, 然后转化为字符串  
let list = list.filter(|i| i > 0).map(|i| i.to_string());
</code></pre><p>这并非特定于编程语言的概念, lambda 演算被广泛运用于各种领域, 它的地位实际上与图灵机相同<br> 诸如 "柯里化" 等特性都源自于 lambda 演算, 鼎鼎有名的 LISP, ML, Haskell 等众多语言, 都源自于 lambda 演算<p>它存在着三条重要的法则:<ul><li>Alpha转换: 重命名操作, 变量的名称是不重要的<br> 比如上述的 <code>filter(|i| > 0)</code> 可以写作 <code>filter(|x| x > 0)</code> <br><li>Beta规约: 将参数值替换掉标识符<br> 比如 <code>filter(|x| x > 0)</code> 中, 用 10 代入到 x 进行运算<br> 别小看这条法则, 这是最最重要的一条, 也是后面讲的时候花费篇幅最长的一条<br> 这条法则, 使得 lambda 是图灵等价的一种理论, 也是之所以可以图灵完备的难的时候非常难) <br><li>Eta化简: 避免等价函数的无意义膨胀, 阐明了不同形式的 lambda 的内在相等性<br> <code>|x| x.to_string()</code> 等价于 <code>|x| to_string(x)</code> 等价于 <code>to_string</code><br> 这会晓得为什么有些语言中, 当你传入这样闭包时, 会建议你改写成第三种形式了吧? <br></ul><p>你肯定知道编程语言中的 Bool 类型, 还有 if/then/else 语句<br> lambda 演算不仅可以定义数字类型, 还能表达 布尔类型/重复/递归/分支 等<br> 在之后的章节, 我们会利用上述的三条法则, 了解如何用 haskell 自己写一套 bool 类型, 与 if-else 语句<br> (其实很简单~~)<hr><h1 id=shi-li>示例</h1><p>以上是对函数式的小小概括<br> 还有诸如柯里化, 惰性求值, 多态性, 类型约束等内容, 将会放在后面配合代码讲解<p>为了吸引小崽子们来学 Haskell, 能骗几个是几个, 特意来几段无比简洁的代码<ul><li>埃氏筛求素数:</ul><pre class=language-haskell data-lang=haskell><code class=language-haskell data-lang=haskell>primes = filterPrime [2..]
  where filterPrime (p:xs) = p : filterPrime [x | x &LT- xs, x `mod` p /= 0]
</code></pre><ul><li>斐波那契数列:</ul><pre class=language-haskell data-lang=haskell><code class=language-haskell data-lang=haskell>fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
</code></pre><ul><li>快速排列:</ul><pre class=language-haskell data-lang=haskell><code class=language-haskell data-lang=haskell>qsort [] = []
qsort (x : xs) = qsort sList ++ [x] ++ qsort bList
  where (sList, bList) = partition (< x) xs
</code></pre><ul><li>辗转相除法求最大公约数:</ul><pre class=language-haskell data-lang=haskell><code class=language-haskell data-lang=haskell>gcd' x y
  | y == 0 = x
  | otherwise = gcd' y (x `mod` y)
</code></pre><p>感谢你的观看, 咋们下期见!!<br> 先让我鸽几天 :)</div></div><div class=bottom-footer style=height:140vh><div class="flex flex-col text-center border-t-2 py-8" style=background-color:#3b3b3b><span> <i class="iconfont icon-aixin text-red-500 align-middle"> </i> <span class=opacity-70> Jedsek </span> </span></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class=pl-4><span> 哈喽, 哈喽!!!! 这里应该算是一个几乎不算彩蛋的小彩蛋吧? 只有当你浏览具有 目录|TOC 的文章时, 此段才会渲染<br> 其实这里是特意留白出来的底部 footer, 保证了当你点击右侧的 目录|TOC 且是最后一个 anchor 时, 一定能高亮它 <br> <br> 你可以想象一下, 如果没有这段 footer, 那么点击锚点时, 当最后一段目录的内容只有几行字时 <br> 由于底部行数过少, 就只能高亮到上面的锚点啦! <br> <br> 毕竟我高亮目录的实现思路, 是获取当前滚动的Y偏移量, 与锚点对应的 h1/h2 在博客左侧主体的Y偏移量, 进行计算来判断高亮哪个~ <br> 简单来说, 当 (window.scrollY + 200) >= anchor.offsetTop 时, 就会选择这个anchor, 随后进行高亮 <br> <br> 你可以试试在浏览器中按 F12 打开开发者工具, ctrl-c 选择此处 class 名称为 "bottom-footer" 的 div, 然后删除该结点 <br> 然后按 F12 退出开发者工具, 随后点击右侧的 目录|TOC 中的结点, 当最后一个 anchor 的内容过少时, 锚点无法被高亮 <br> 当然, 当最后一个 anchor 的行数稍微多一些时, 照样能够高亮最后一个目录 <br> <br> 如果你发现有无法高亮的情况, 嗯......那应该不太可能呢, 诶嘿～ </span><br><br></div><br></div></div><div class="sidebar flex-col w-48" style=display:flex><script>var show_sidebar_at_startup=(()=>{const a=document.getElementsByClassName(`sidebar`)[0];if(/Mobi|Android|iPhone/i.test(navigator.userAgent)&&a.style.display==`flex`){a.style.display=`none`}});show_sidebar_at_startup()</script><div class="nav flex flex-col gap-2 pb-auto opacity-100 text-center p-2" style=background-color:#2e2e2e><a class="text-xl font-medium no-underline hover:scale-110 duration-300" href=/ style=background-color:#2e2e2e> Jedsek's blog </a><span class="text-sm italic" style=background-color:#2e2e2e> 与其浊富 | 宁比清贫 </span><a href=/about style=background-color:#2e2e2e> <img class="my-avatar p-2 duration-300 hover:scale-110 hover:rotate-12 hover:rounded-3xl hover:opacity-80" src=/images/avatar.webp style=background-color:#2e2e2e> </a><nav class="px-2 pt-1"><ul class="list-none pl-0" id=menu><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/> <i class="iconfont icon-home left"></i> <span class="iconfont mr-10">首页</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-top duration-1000"><a class="no-underline block" href=/about> <i class="iconfont icon-about left"></i> <span class="iconfont mr-10">关于</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/sayings> <i class="iconfont icon-yulu left"> </i> <span class="iconfont mr-10">语录</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-top duration-1000"><a class="no-underline block" href=/categories> <i class="iconfont icon-Z-fenleidaohang left"></i> <span class="iconfont mr-10">分类</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/novels> <i class="iconfont icon-config_s left"></i> <span class="iconfont mr-10">小说</span> </a></ul></nav></div><script></script><div class="sticky top-0"><aside class="toc flex flex-col border-t-2 px-2 py-1 my-2"><div class="text-center text-2xl">目录|TOC</div><ul class="list-none px-2 text-left"><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#bian-cheng-fan-shi>编程范式</a><li class="py-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><span class=pl-2> ├─<a class=text-sm href=#gai-lan>概览</a></span><li class="py-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><span class=pl-2> └─<a class=text-sm href=#zong-jie>总结</a></span><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#gao-jie-han-shu>高阶函数</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#bu-ke-bian-shu-ju>不可变数据</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#fu-zuo-yong>副作用</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#yin-yong-tou-ming>引用透明</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#chun-han-shu>纯函数</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#lambdayan-suan>Lambda演算</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#shi-li>示例</a></ul></aside></div></div><div class="float-botton flex"><a class="float-botton-item no-underline" href=#> <i class="iconfont icon-arrowup"></i> </a><div class=float-bottton-seperator></div><div class="float-botton-item float-botton-toggle-sidebar" type=button><i class="iconfont icon-sidebar"></i></div></div></div><script src=/scripts/custom/ul.js></script><script src=/scripts/third_party/lightgallery.min.js></script><script src=/scripts/custom/fancybox.js></script><script src=/scripts/custom/codeblock.js></script><script src=/scripts/custom/sidebar.js></script><script src=/scripts/custom/toc.js></script><script>hljs.highlightAll();document.addEventListener(`pjax:complete`,()=>{hljs.highlightAll()})</script>