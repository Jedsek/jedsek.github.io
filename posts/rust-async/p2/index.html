<!doctype html><html class=scroll-smooth lang=zh-Hans><head><meta charset=utf-8><link crossorigin href=/manifest.json rel=manifest><script src=/scripts/custom/loadscript.js></script><link href=/styles/third_party/highlight.min.css rel=stylesheet><link href=/styles/third_party/highlight_themes/atom-one-dark.css rel=stylesheet><script src=/scripts/third_party/pjax.min.js></script><script src=/scripts/third_party/quicklink.umd.min.js></script><script src=/scripts/third_party/jquery.min.js></script><script src=/scripts/third_party/highlight/highlight.min.js></script><script src=/scripts/third_party/highlight/languages/rust.min.js></script><script src=/scripts/third_party/highlight/languages/nix.min.js></script><script src=/scripts/third_party/highlight/languages/haskell.min.js></script><script src=/scripts/third_party/highlight/languages/gleam.min.js></script><script src=/scripts/third_party/highlight/languages/scheme.min.js></script><link href=/iconfonts/iconfont.css rel=stylesheet><link href=/styles/custom/tailwind.css rel=stylesheet><link href=/styles/custom/style.css rel=stylesheet><script src=/scripts/custom/pjax.js></script><script src=/scripts/custom/pwa_install.js></script><script>document.documentElement.setAttribute(`data-theme`,`dark`)</script><script>if(navigator.serviceWorker!=null){navigator.serviceWorker.register(`/sw.js`).then((a=>{console.log(`Registered events at scope: `,a.scope)}))}</script><script>var GetCookie=(a=>{let e=0;var b=document.cookie.split(`;`);for(var c=e;c<b.length;c++){var d=b[c].split(`=`);if(a==d[e]){return unescape(d[1])}};return null});var SetCookie=((a,b)=>{document.cookie=a+ `=`+ escape(b)+ `; SameSite=None; Secure;`});var scrollback=(()=>{let a=`scroll`;if(GetCookie(a)!=null){const b=GetCookie(a);document.documentElement.scrollTo({top:b,left:0,behavior:`instant`})}})</script><script>window.addEventListener(`load`,()=>{quicklink.listen()})</script><script>loadExternalScript(`//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js`,(()=>{console.log(`External script loaded and executed.`)}));document.addEventListener(`pjax:complete`,(()=>{loadExternalScript(`//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js`,(()=>{console.log(`External script loaded and executed.`)}))}))</script><title> Jedsek | Blog </title><body onscroll='SetCookie("scroll",document.documentElement.scrollTop);' class=flex id=body onload=scrollback();><script src=/scripts/custom/fireworks.js></script><div class="flex flex-rol grow"><div class="content w-80 flex flex-col break-words pr-2 border-2 grow border-b-0 border-neutral-800 animate-in fade-in slide-in-from-top-8 duration-1000" style=background-color:#3b3b3b><div class=break-words style=min-height:100vh><div class="p-4 flex justify-center text-4xl" style=opacity:.84>rust-async-p2~> 异步简介</div><div class="p-4 flex align-center text-sm hover:scale-125 duration-300 w-fit" style=color:#999;margin-top:-16px;margin-left:auto;margin-right:auto><~~ 发表日期:2021-09-12 | 访问量: <span class=text-sm id=busuanzi_container_page_pv style=color:#999> <span class=text-sm id=busuanzi_value_page_pv style=color:#999></span></span> | 本文词数:1176 | 预计阅读时间:6分钟 ~~></div><div class=p-4><blockquote><p>来简单介绍一下异步吧</blockquote><span id=continue-reading></span><p>同系列传送门: <a href=/categories/rust-async>rust-async</a><h1 id=kai-pian>开篇</h1><p><strong>异步编程 (Asynchronous programming)</strong>, 是一种<strong>并发编程模型</strong><br> 特点是通过少量<code>OS_thread(系统线程)</code>, 即可运行大量<code>并发任务</code>, 在某些场景下,可以疯狂压榨cpu的性能<hr><h1 id=mo-xing-dui-bi>模型对比</h1><p>为何选择异步,它的优势有哪些? 让我们对比下 <strong>异步</strong> 与其他 <strong>并发模型</strong>:<p>1.<code>系统线程 (OS Thread)</code><br> 由操作系统提供线程,进行并发,如 <code>std::thread</code><ul><li>简单易使用, 建模能力强, 足够传统<li>操作系统就是运行时, 与C语言交互方便<li>数据同步困难, 易发生数据竞争<li>小型任务数量巨大时, 若分别开一个线程, 所需内存与创建线程开销巨大, 性价比极低</ul><p>2.<code>绿色线程 (Green Thread)</code><br> 它几乎与系统线程一样, 不过 <code>Runtime(运行时,jvm/.net听说过吗?)</code> 从操作系统变为了程序本身, 由程序本身进行模拟<br> Rust在1.0版本前删去了它, 因为它不能在语言层面被 Rust 支持, 但可以使用相关库<ul><li>程序本身对绿色线程有绝对的管理权, 内存分配的粒度更细, 能根据任务大小进行调度, 堆栈可以随时间推移而增长<li>创建/销毁/切换线程的代价又低又快, 轻松创建成千上万个绿色线程, 来处理任务<li>由程序本身实现模拟出来, Runtime 较大<li>如果放在语言层面支持Runtime, 其会一直存在, 即使不使用该特性, 也会拖累性能, 难以与C库交互<li>绿色线程在不同平台上,其实现可能不同<li>对多平台的支持/维护/改进得靠实现者保证</ul><hr><h1 id=yi-bu>异步</h1><p>我们以IO操作为例子, 假设我们正在单线程下, 读取文件, 并进行一个计算:<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let file = /*  */
let content = read(file);
compute()
</code></pre><p>读取 <code>file</code>, 获取 <code>content</code>, 在此期间, 我们做不了任何其他事, 得等待<code>IO操作(Input/Output, 输入/输出)</code> 完毕, 才能进行接下来的 <code>compute</code><br> <code>读取文件</code>, 属于<code>IO操作</code>, 众所周知, IO操作很耗时, 等待它完成的时间可能会很长, 可以使用系统线程加速:<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let file = /*  */
// 为每个读取任务新建线程, 并获取句柄
let handle_a = thread::spawan(|| read(file) );
let handle_b = thread::spawan(|| compute() );
// 使用 join 阻塞调用线程, 确保句柄线程执行结束
let content = handle_a.join().unwrap();
handle_b.join().unwrap();
</code></pre><p>两个任务 <code>read</code> 与 <code>compute</code> 是独立无依赖的, 所以我们<code>spawn</code>了两个线程<ul><li>第一个用于读取文件,获取数据<li>第二个用于执行 <code>compute</code></ul><p>速度虽然上去了, 但代价就是额外创建两个线程的开销, 而之后的异步仅依靠单线程, 也能完成上面的操作<br> 单线程中的异步(伪)代码如下:<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>let file = /*  */
let content = read_async(file);
compute_async()
</code></pre><p>你会注意到:<ul><li><code>read</code> -> <code>read_async</code><li><code>compute</code> -> <code>compute_async</code></ul><p>伪代码表示, 这两操作变成了异步的, 现在你无需关注这是如何变成异步的, 此处仅为为说明异步的概念:<ul><li><p><code>read</code>:<br> 它会阻塞调用线程,等待该操作完毕后, 才继续往下执行 <code>compute</code><br> 阻塞期间是几乎不需要 cpu 参与运行的, 程序此时傻乎乎地等待阻塞结束, 无疑是对性能的浪费, 对cpu的不尊重 <br></p><li><p><code>read_async</code>:<br> 它处于阻塞时,会运行 <code>compute_async</code>, 线程由 <code>read_async</code> 接管, 变为由 <code>compute_async</code> 接管<br> 当阻塞时间结束,则程序继续变为运行<code>read_async</code> <br></p></ul><p>瞧, <code>read_async</code> 操作阻塞, 无法取得进展时, 其他异步任务将被执行, 由其他异步任务接管线程<br> 总而言之, 异步其实就是当前操作处于阻塞时, 能运行其他不阻塞的操作 (如果有), 使得cpu一直处于运算, 性能被极限压榨<br> 异步操作, 就像是可以随意 <code>start/stop</code> 一般, 调度程序能进行调度, 决定当前要运算哪个, 确保不会因阻塞而傻傻等待<p>即使是单线程, 也能做到同时运行多个 <code>Task(异步任务)</code>, 而异步结合多线程也是可以的, 只要存在耗时的IO操作<br> 如果是非IO密集型, 而是计算密集型, 建议直接使用多线程, 不然就用异步<hr><h1 id=wei-sheng>尾声</h1><p>Q:<br> 阻塞时期还能同时进行其他操作? IO操作不会占用cpu吗?<br> A:<br> 现代电脑发展出了一些分担IO操作压力的高科技, cpu对IO操作的压力较小, IO时能进行其他运算, 只要最后接收数据时出个场就行了<br> 所以我们的程序不需要在IO阻塞时傻傻等待, 给它们找点事情做吧!<hr><p>上一篇: <a href=/posts/rust-async/p1>p1~> 系列说明</a><br> 下一篇: <a href=/posts/rust-async/p3>p3~> Future</a></div></div><div class=bottom-footer style=height:140vh><div class="flex flex-col text-center border-t-2 py-8" style=background-color:#3b3b3b><span> <i class="iconfont icon-aixin text-red-500 align-middle"> </i> <span class=opacity-70> Jedsek </span> </span></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class=pl-4><span> 哈喽, 哈喽!!!! 这里应该算是一个几乎不算彩蛋的小彩蛋吧? 只有当你浏览具有 目录|TOC 的文章时, 此段才会渲染<br> 其实这里是特意留白出来的底部 footer, 保证了当你点击右侧的 目录|TOC 且是最后一个 anchor 时, 一定能高亮它 <br> <br> 你可以想象一下, 如果没有这段 footer, 那么点击锚点时, 当最后一段目录的内容只有几行字时 <br> 由于底部行数过少, 就只能高亮到上面的锚点啦! <br> <br> 毕竟我高亮目录的实现思路, 是获取当前滚动的Y偏移量, 与锚点对应的 h1/h2 在博客左侧主体的Y偏移量, 进行计算来判断高亮哪个~ <br> 简单来说, 当 (window.scrollY + 200) >= anchor.offsetTop 时, 就会选择这个anchor, 随后进行高亮 <br> <br> 你可以试试在浏览器中按 F12 打开开发者工具, ctrl-c 选择此处 class 名称为 "bottom-footer" 的 div, 然后删除该结点 <br> 然后按 F12 退出开发者工具, 随后点击右侧的 目录|TOC 中的结点, 当最后一个 anchor 的内容过少时, 锚点无法被高亮 <br> 当然, 当最后一个 anchor 的行数稍微多一些时, 照样能够高亮最后一个目录 <br> <br> 如果你发现有无法高亮的情况, 嗯......那应该不太可能呢, 诶嘿～ </span><br><br></div><br></div></div><div class="sidebar flex-col w-48" style=display:flex><script>var show_sidebar_at_startup=(()=>{const a=document.getElementsByClassName(`sidebar`)[0];if(/Mobi|Android|iPhone/i.test(navigator.userAgent)&&a.style.display==`flex`){a.style.display=`none`}});show_sidebar_at_startup()</script><div class="nav flex flex-col gap-2 pb-auto opacity-100 text-center p-2" style=background-color:#2e2e2e><a class="text-xl font-medium no-underline hover:scale-110 duration-300" href=/ style=background-color:#2e2e2e> Jedsek's blog </a><span class="text-sm italic" style=background-color:#2e2e2e> 与其浊富 | 宁比清贫 </span><a href=/about style=background-color:#2e2e2e> <img class="my-avatar p-2 duration-300 hover:scale-110 hover:rotate-12 hover:rounded-3xl hover:opacity-80" src=/images/avatar.webp style=background-color:#2e2e2e> </a><nav class="px-2 pt-1"><ul class="list-none pl-0" id=menu><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/> <i class="iconfont icon-home left"></i> <span class="iconfont mr-10">首页</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-top duration-1000"><a class="no-underline block" href=/about> <i class="iconfont icon-about left"></i> <span class="iconfont mr-10">关于</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/sayings> <i class="iconfont icon-yulu left"> </i> <span class="iconfont mr-10">语录</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-top duration-1000"><a class="no-underline block" href=/categories> <i class="iconfont icon-Z-fenleidaohang left"></i> <span class="iconfont mr-10">分类</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/novels> <i class="iconfont icon-config_s left"></i> <span class="iconfont mr-10">小说</span> </a></ul></nav></div><script></script><div class="sticky top-0"><aside class="toc flex flex-col border-t-2 px-2 py-1 my-2"><div class="text-center text-2xl">目录|TOC</div><ul class="list-none px-2 text-left"><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#kai-pian>开篇</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#mo-xing-dui-bi>模型对比</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#yi-bu>异步</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#wei-sheng>尾声</a></ul></aside></div></div><div class="float-botton flex"><a class="float-botton-item no-underline" href=#> <i class="iconfont icon-arrowup"></i> </a><div class=float-bottton-seperator></div><div class="float-botton-item float-botton-toggle-sidebar" type=button><i class="iconfont icon-sidebar"></i></div></div></div><script src=/scripts/custom/ul.js></script><script src=/scripts/third_party/lightgallery.min.js></script><script src=/scripts/custom/fancybox.js></script><script src=/scripts/custom/codeblock.js></script><script src=/scripts/custom/sidebar.js></script><script src=/scripts/custom/toc.js></script><script>hljs.highlightAll();document.addEventListener(`pjax:complete`,()=>{hljs.highlightAll()})</script>