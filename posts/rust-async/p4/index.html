<!doctype html><html class=scroll-smooth lang=zh-Hans><head><meta charset=utf-8><link crossorigin href=/manifest.json rel=manifest><script src=/scripts/custom/loadscript.js></script><link href=/styles/third_party/highlight.min.css rel=stylesheet><link href=/styles/third_party/highlight_themes/atom-one-dark.css rel=stylesheet><script src=/scripts/third_party/pjax.min.js></script><script src=/scripts/third_party/quicklink.umd.min.js></script><script src=/scripts/third_party/jquery.min.js></script><script src=/scripts/third_party/highlight/highlight.min.js></script><script src=/scripts/third_party/highlight/languages/rust.min.js></script><script src=/scripts/third_party/highlight/languages/nix.min.js></script><script src=/scripts/third_party/highlight/languages/haskell.min.js></script><script src=/scripts/third_party/highlight/languages/gleam.min.js></script><script src=/scripts/third_party/highlight/languages/scheme.min.js></script><link href=/iconfonts/iconfont.css rel=stylesheet><link href=/styles/custom/tailwind.css rel=stylesheet><link href=/styles/custom/style.css rel=stylesheet><script src=/scripts/custom/pjax.js></script><script src=/scripts/custom/pwa_install.js></script><script>document.documentElement.setAttribute(`data-theme`,`dark`)</script><script>if(navigator.serviceWorker!=null){navigator.serviceWorker.register(`/sw.js`).then((a=>{console.log(`Registered events at scope: `,a.scope)}))}</script><script>var GetCookie=(a=>{let e=0;var b=document.cookie.split(`;`);for(var c=e;c<b.length;c++){var d=b[c].split(`=`);if(a==d[e]){return unescape(d[1])}};return null});var SetCookie=((a,b)=>{document.cookie=a+ `=`+ escape(b)+ `; SameSite=None; Secure;`});var scrollback=(()=>{let a=`scroll`;if(GetCookie(a)!=null){const b=GetCookie(a);document.documentElement.scrollTo({top:b,left:0,behavior:`instant`})}})</script><script>window.addEventListener(`load`,()=>{quicklink.listen()})</script><script>loadExternalScript(`//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js`,(()=>{console.log(`External script loaded and executed.`)}));document.addEventListener(`pjax:complete`,(()=>{loadExternalScript(`//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js`,(()=>{console.log(`External script loaded and executed.`)}))}))</script><title> Jedsek | Blog </title><body onscroll='SetCookie("scroll",document.documentElement.scrollTop);' class=flex id=body onload=scrollback();><script src=/scripts/custom/fireworks.js></script><div class="flex flex-rol grow"><div class="content w-80 flex flex-col break-words pr-2 border-2 grow border-b-0 border-neutral-800 animate-in fade-in slide-in-from-top-8 duration-1000" style=background-color:#3b3b3b><div class=break-words style=min-height:100vh><div class="p-4 flex justify-center text-4xl" style=opacity:.84>rust-async-p4~> 状态的保存与变换</div><div class="p-4 flex align-center text-sm hover:scale-125 duration-300 w-fit" style=color:#999;margin-top:-16px;margin-left:auto;margin-right:auto><~~ 发表日期:2021-09-12 | 访问量: <span class=text-sm id=busuanzi_container_page_pv style=color:#999> <span class=text-sm id=busuanzi_value_page_pv style=color:#999></span></span> | 本文词数:2076 | 预计阅读时间:11分钟 ~~></div><div class=p-4><blockquote><p>浅显的原理第一篇: 状态的保存/变换</blockquote><span id=continue-reading></span><p>同系列传送门: <a href=/categories/rust-async>rust-async</a><h1 id=kai-pian>开篇</h1><p><strong>注</strong>: 参考了 <&LTWriting an OS in Rust>> 中的 async 篇,可以自己搜索下看看<br> 为了更好地理解 <code>Rust异步</code>背后的原理, 我们先了解下一些概念, 当然, 只是小补充而已:<ul><li>多任务: 抢占式与协作式<li>状态机<li>自引用结构体</ul><p>现在,让我们开始吧!<hr><h1 id=liang-chong-duo-ren-wu>两种多任务</h1><h2 id=jie-shao>介绍</h2><p>抢占式 与 协作式, 是 多任务 的不同分类<ul><li><p>抢占式多任务:<br> 操作系统决定CPU的运行权<br> 比如, 操作系统先让网易云音乐运行一会, 再让 VSCode 运行一会<br> 各个程序中的任务们, 运行时间很短, 但切换速度也很快, 造成一种任务们同时运行的感觉<br> 这是强迫/抢占的 <br></p><li><p>协作式多任务:<br> 任务们本身进行协调, 决定CPU的运行权<br> 比如Rust中, 运行时调用某 Task(top-level Future) 的 poll 阻塞时, 返回 Poll::Pending<br> 自己放弃继续执行, 并通知运行时执行其他Task<br> 这是自愿/协作的, Task 们自愿放弃CPU的执行权 <br></p></ul><h2 id=zhuang-tai-de-hui-fu-bao-cun>状态的恢复/保存</h2><p>既然任务们能互相切换执行, 那么, 当再次轮到某任务执行时<br> 该任务,应当从先前暂停的地方开始, 继续执行<br> 因此我们应当备份某任务的先前状态, 以便于之后的继续执行, 这就是 状态保存<p>对于 抢占式 与 协作式, 处理 状态保存 的思路是不一样的:<ul><li>抢占式:<br> 因为是强迫切换执行的, 任务会在任意某个时刻被中断<br> 任务此时运行到了哪里?我们不知道啊!<br> 那么, 就只好将任务的所有状态全部保存, 包括调用栈(call stack) <br></ul><p>反正, 你只需明白, 操作系统强制切换任务, 为每个任务分配相对公平的执行时间<br> 但是, 代价也有, 比如不得不为每个任务保存它的所有状态, 内存开销大<ul><li>协作式:<br> 因为是自愿/协作地切换执行, 每个任务会在哪里放弃执行都是清楚的<br> 这种放弃执行权的操作, 我们称为<code>yield</code> <br></ul><p>比如在Rust中, <code>xxx.await</code>会执行一个Future<br> 意味着当程序执行到这里时, 可能会<code>yield</code>(poll返回Poll::Pending, 自愿放弃执行权)<p><code>xxx.await</code>就是一个<code>stop/yield point</code>, 代表执行到此处时, 可能会发生暂停并yield<br> 瞧, 所有可能yield的地方你都知道, 这就方便了保存状态(你可以舍弃已经不需要的中间变量)<br> 因此, 我们可以准确分配Future执行所需要的最大空间<p>其实, 每个<code>.await(也就是yield point)</code>, 就代表着<code>一种状态</code>(之后会讲)<p>协作式的好处在于:<br> 能自己掌握所有<code>yield point</code>, 从而精打细算地选择最优的策略, 而非让操作系统为你暗地里处理<br> 毕竟机器定义的分配策略, 总是没有比不过我们特意设计的<br> 在任务暂停并转让执行权前, 准确保存<code>下次继续所需要的状态</code>, 内存/性能优势很大<br> 但坏处也有: 因为这是自愿/协作的, 当某个任务出现Bug, 永不放弃执行权, 其他任务便无法执行<hr><h1 id=zhuang-tai-ji-de-gai-nian>状态机的概念</h1><p>在Rust中的异步, 我们之前也说过, 属于<code>协作式多任务</code><br> 而其<code>状态保存</code>的实现, 就是利用<code>状态机(state machine)</code>来实现<p><code>状态机(state machine)</code>一般指<code>有限状态自动机</code>, 是一种数学模型<ol><li>状态(state):<br> 比如有一扇门, 它的状态就处于以下两种之一: Open or Closed <br><li>事件(event):<br> 某事件发生后, 会触发相应动作, 可能改变状态<br> 比如: 用钥匙锁门(event)=>关门(action)=>门被锁住(state) <br><li>动作 (action):<br> 事件发生后, 会触发动作<li>变换 (transition):<br> <code>State_X=>State_Y</code>就叫<code>变换</code>, 比如门的状态从<code>Open=>Closed</code> <br></ol><p>稍微了解下<code>状态机</code>的概念即可<p>那么现在, 就要看具体代码了<p>如果你想亲自运行一下, 先确保你的<code>Cargo.toml</code>中的依赖如下:<pre class=language-toml data-lang=toml><code class=language-toml data-lang=toml>[dependencies]
async-std = {version = "1", features = ["attributes", "unstable"]}
</code></pre><p>如下代码, 读取一个文件的行数<br> 你可以通过 <code>cargo run -- ./src/main.rs</code> 运行<br> (通过target目录下的可执行文件, 加上参数后运行, 也可以哦)<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>use std::{
	env::args,
	process,
};
use async_std::{
	prelude::*,
	fs::File,
	io::{self,BufReader},
};
#[async_std::main]
async fn main() -> io::Result<()> {              // Start
	let path = args().nth(1).unwrap_or_else(||{
		eprintln!("Fuck you! No path for reading");
		process::exit(1);
	}); 
	let file = File::open(path).await?;          // Yield point
	let lines = BufReader::new(file).lines();
	let count = lines.count().await;             // Yield point
	println!("This file contains {} lines",count);
	Ok(())
}                                                // Done
</code></pre><p>mian()产生一个新实例, 异步运行<code>open(path)</code>与<code>count()</code><br> 对于编译器, 每一个<code>.await</code>其实都代表一种状态<p>Future实例, 实际上是个状态机<br> 在这里共有四种状态/阶段(其中包括两个<code>.await point(yield point)</code>):<ol><li>Start: 此Future刚开始执行<li>Yield1: 第一个 yield point<li>Yield2: 第二个 yield point<li>Done: 此Future执行完毕</ol><p>这些状态的含义是: <code>表示当前Future执行到了哪一个阶段</code><br> 执行器调用当前Future的poll推动进度时, 若在<code>某一阶段</code>返回了<code>Poll::Pending</code>, 则放弃执行权<br> 当再次调用当前Future的poll推动进度时, 则从上次暂停的状态<code>恢复(resume)</code>, 继续执行<p>官方目前似乎采用<code>Generator(生成器)</code>为异步语法生成状态机, 每个状态都会存储一些数据, 便于进入下一个状态<p><strong>Note 1</strong>:<br> Start状态, 会存储传入函数的参数(如果有参数)<p><strong>Note 2</strong>:<br> Done状态下, 若进行resume, 则可能得到panic! 因为恢复已结束的计算是不可能, 也不应该的<p><strong>Note 3</strong>:<br> 怎么判断每个状态需要保存哪些变量? 很简单的一句话:<br> <code>某个yield point之前定义,  且point之后还需要使用的变量</code><br> 如上段代码中的 <code>file</code> 与 <code>count</code>就需要被保存, 因为从暂停中恢复后还需要使用<br> 其他的变量, 是一次性执行完的, 不会出现什么暂停一下, 等会继续的现象<br> 所以不需要特殊的持久化操作<hr><h1 id=zi-yin-yong-jie-gou-ti>自引用结构体</h1><h2 id=bao-cun-yin-yong>保存引用</h2><p>当每个状态存储数据时, 可能会导致发生<code>自引用</code>, 比如:<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>async fn example() -> i32 {                            // Start
    let arr = [1, 2, 3];
    let element = &arr[2];
    write_file("foo.txt", element.to_string()).await;  // Yield1
    *element                                           // Done
}
</code></pre><p>这里有三个状态: <code>Start</code>, <code>Yield1</code>, <code>Done</code>, 而在<code>Yield1</code>这个状态下, 存储的数据如下:<pre class=language-rust data-lang=rust><code class=language-rust data-lang=rust>// 状态的定义
struct Yield1State {
    arr: [i32; 3], 
    element: *const i32, // 数组最后一个元素的地址
}
// 状态的实例
Yield1State {
    arr: [1,2,3],
    element: &arr[2] as *const i32,
}
</code></pre><p>等等, 你可能会对上面的代码有疑惑:<br> 不是说, 状态只需要保存 <code>在yield point之前定义,  并且该point之后还需要使用的变量</code> 吗<br> 上面的代码, 只有element这个引用需要被保存吧?<p>这是因为, 它是<code>引用</code>嘛! 没了<code>引用</code>背后的实际数据, 那它还有啥用, 不就是<code>悬垂引用</code>了吗?<br> 因此我们还得保存, <code>该引用</code>指向的背后数据: <code>arr</code>, 并<strong>一起</strong>存储在同个<code>struct(代表同一状态)</code>中<br> 像这种 <code>结构体内部的指针, 指向结构体本身</code>, 就叫 <code>自引用结构</code><p>比如上面代码: 同一结构体下, 成员element指向了成员arr<h2 id=nei-cun-yi-dong-wen-ti>内存移动问题</h2><p>如上所述, 这可能导致悬垂引用的产生, 若该struct实例的<code>内存地址发生改变</code>, 如使用 <code>std::mem</code>, 让struct实例的内存地址发生移动<br> 以上面的那段代码为例, 如下:<ul><li>arr:<br> 内存地址会跟着结构体实例而改变, 但是, <code>值仍然是 [1, 2, 3]</code><li>element:<br> 内存地址会跟着结构体实例而改变, 但是, 值仍然是<code>先前arr的地址</code>, <code>注意, 是先前的 ! 而不是后来arr的新地址</code></ul><p>这就产生了一个问题: 引用可能是失效/错误的(悬垂引用)<br> 官方提出了<code>std::pin::Pin(trait)</code> 来解决自引用结构体方面的悬垂指针/引用问题<p>其实你听名字也很好理解, <code>Pin(中文意思是钉子)</code>的作用是, 防止内存地址发生改变(给爷钉死吧!)<br> 但是它又是怎么pin住的呢? 下一节再慢慢讲吧, 那又是一个值得探讨的话题了<p>欲知后事如何, 且听下回分解<br> <del>(疯狂省略, 因为我累死了, 多么希望赶紧结束这一P啊 ! !)</del><hr><p>上一篇: <a href=/posts/rust-async/p3>p3~> Future</a></div></div><div class=bottom-footer style=height:140vh><div class="flex flex-col text-center border-t-2 py-8" style=background-color:#3b3b3b><span> <i class="iconfont icon-aixin text-red-500 align-middle"> </i> <span class=opacity-70> Jedsek </span> </span></div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class=pl-4><span> 哈喽, 哈喽!!!! 这里应该算是一个几乎不算彩蛋的小彩蛋吧? 只有当你浏览具有 目录|TOC 的文章时, 此段才会渲染<br> 其实这里是特意留白出来的底部 footer, 保证了当你点击右侧的 目录|TOC 且是最后一个 anchor 时, 一定能高亮它 <br> <br> 你可以想象一下, 如果没有这段 footer, 那么点击锚点时, 当最后一段目录的内容只有几行字时 <br> 由于底部行数过少, 就只能高亮到上面的锚点啦! <br> <br> 毕竟我高亮目录的实现思路, 是获取当前滚动的Y偏移量, 与锚点对应的 h1/h2 在博客左侧主体的Y偏移量, 进行计算来判断高亮哪个~ <br> 简单来说, 当 (window.scrollY + 200) >= anchor.offsetTop 时, 就会选择这个anchor, 随后进行高亮 <br> <br> 你可以试试在浏览器中按 F12 打开开发者工具, ctrl-c 选择此处 class 名称为 "bottom-footer" 的 div, 然后删除该结点 <br> 然后按 F12 退出开发者工具, 随后点击右侧的 目录|TOC 中的结点, 当最后一个 anchor 的内容过少时, 锚点无法被高亮 <br> 当然, 当最后一个 anchor 的行数稍微多一些时, 照样能够高亮最后一个目录 <br> <br> 如果你发现有无法高亮的情况, 嗯......那应该不太可能呢, 诶嘿～ </span><br><br></div><br></div></div><div class="sidebar flex-col w-48" style=display:flex><script>var show_sidebar_at_startup=(()=>{const a=document.getElementsByClassName(`sidebar`)[0];if(/Mobi|Android|iPhone/i.test(navigator.userAgent)&&a.style.display==`flex`){a.style.display=`none`}});show_sidebar_at_startup()</script><div class="nav flex flex-col gap-2 pb-auto opacity-100 text-center p-2" style=background-color:#2e2e2e><a class="text-xl font-medium no-underline hover:scale-110 duration-300" href=/ style=background-color:#2e2e2e> Jedsek's blog </a><span class="text-sm italic" style=background-color:#2e2e2e> 与其浊富 | 宁比清贫 </span><a href=/about style=background-color:#2e2e2e> <img class="my-avatar p-2 duration-300 hover:scale-110 hover:rotate-12 hover:rounded-3xl hover:opacity-80" src=/images/avatar.webp style=background-color:#2e2e2e> </a><nav class="px-2 pt-1"><ul class="list-none pl-0" id=menu><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/> <i class="iconfont icon-home left"></i> <span class="iconfont mr-10">首页</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-top duration-1000"><a class="no-underline block" href=/about> <i class="iconfont icon-about left"></i> <span class="iconfont mr-10">关于</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/sayings> <i class="iconfont icon-yulu left"> </i> <span class="iconfont mr-10">语录</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-top duration-1000"><a class="no-underline block" href=/categories> <i class="iconfont icon-Z-fenleidaohang left"></i> <span class="iconfont mr-10">分类</span> </a><li class="hover:scale-110 hover:opacity-60 hover:duration-300 hover:translate-x-2 hover:-translate-y-2 py-1 animate-in fade-in slide-in-from-bottom duration-1000"><a class="no-underline block" href=/novels> <i class="iconfont icon-config_s left"></i> <span class="iconfont mr-10">小说</span> </a></ul></nav></div><script></script><div class="sticky top-0"><aside class="toc flex flex-col border-t-2 px-2 py-1 my-2"><div class="text-center text-2xl">目录|TOC</div><ul class="list-none px-2 text-left"><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#kai-pian>开篇</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#liang-chong-duo-ren-wu>两种多任务</a><li class="py-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><span class=pl-2> ├─<a class=text-sm href=#jie-shao>介绍</a></span><li class="py-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><span class=pl-2> └─<a class=text-sm href=#zhuang-tai-de-hui-fu-bao-cun>状态的恢复/保存</a></span><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#zhuang-tai-ji-de-gai-nian>状态机的概念</a><li class="pb-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><a class=text-sm href=#zi-yin-yong-jie-gou-ti>自引用结构体</a><li class="py-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><span class=pl-2> ├─<a class=text-sm href=#bao-cun-yin-yong>保存引用</a></span><li class="py-0 leading-normal animate-in fade-in slide-in-from-bottom duration-1000"><span class=pl-2> └─<a class=text-sm href=#nei-cun-yi-dong-wen-ti>内存移动问题</a></span></ul></aside></div></div><div class="float-botton flex"><a class="float-botton-item no-underline" href=#> <i class="iconfont icon-arrowup"></i> </a><div class=float-bottton-seperator></div><div class="float-botton-item float-botton-toggle-sidebar" type=button><i class="iconfont icon-sidebar"></i></div></div></div><script src=/scripts/custom/ul.js></script><script src=/scripts/third_party/lightgallery.min.js></script><script src=/scripts/custom/fancybox.js></script><script src=/scripts/custom/codeblock.js></script><script src=/scripts/custom/sidebar.js></script><script src=/scripts/custom/toc.js></script><script>hljs.highlightAll();document.addEventListener(`pjax:complete`,()=>{hljs.highlightAll()})</script>